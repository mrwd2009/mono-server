"use strict";var __importDefault=this&&this.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.saveUserProfile=exports.getUserAvatar=exports.getUserLoginHistoryList=exports.deleteUser=exports.editUser=exports.createUser=exports.getUserList=void 0;const zxcvbn_1=__importDefault(require("zxcvbn")),dayjs_1=__importDefault(require("dayjs")),lodash_1=__importDefault(require("lodash")),app_1=__importDefault(require("../../../config/model/app")),password_1=require("../../../lib/util/password"),error_1=require("../../../lib/error"),config_1=__importDefault(require("../../../config/config")),{gateway:{models:{User,UserLoginHistory,UserProfile,RbacUserRole,RbacRole},sequelize}}=app_1.default,getUserList=async a=>{const{rows:e,count:s}=await User.findAndCountAll({attributes:["id","email","reset_password_sent_at","confirmed_at","sign_in_count","current_sign_in_at","last_sign_in_at","current_sign_in_ip","last_sign_in_ip","failed_attempts","locked_at","last_change_pass_at","enabled","created_at","updated_at"],include:[{attributes:["display_name"],model:UserProfile},{attributes:["role_id"],model:RbacUserRole,where:{app:config_1.default.appEnv},required:!1}],...a}),n=[];lodash_1.default.forEach(e,d=>{const t=d.RbacUserRoles;t?.length&&n.push(t[0].role_id)});const o={};if(n.length){const d=await RbacRole.findAll({attributes:["id","name"],where:{id:n}});lodash_1.default.forEach(d,t=>{o[t.id]=t.name})}const l=lodash_1.default.map(e,d=>{const t=d.RbacUserRoles;let u="";return t?.length&&(u=o[t[0].role_id]),{...d.toJSON(),roleName:u}});return{total:s,list:l}};exports.getUserList=getUserList;const createUser=async(a,e)=>{const{email:s,displayName:n,password:o,enabled:l,roleId:d}=a;if((0,zxcvbn_1.default)(o).score<2){const t=new error_1.LogicError(e.t("auth.weekPassword",{password:(0,password_1.randomPassword)()}));throw t.public=!0,t}await sequelize.transaction(async t=>{if(await User.findOne({attributes:["id"],where:{email:s},transaction:t}))throw new error_1.LogicError("User has already existed.");const r=await User.create({email:s,password:o,enabled:l,last_change_pass_at:dayjs_1.default.utc().format()},{transaction:t});if(await UserProfile.create({user_id:r.id,display_name:n},{transaction:t}),d){if(!await RbacRole.findOne({attributes:["id"],where:{id:d,enabled:!0},transaction:t}))throw new error_1.LogicError("Role is not found.");await RbacUserRole.create({user_id:r.id,app:config_1.default.appEnv,role_id:d},{transaction:t})}return!0})};exports.createUser=createUser;const editUser=async(a,e)=>{const{id:s,type:n,enabled:o,roleId:l,displayName:d,password:t}=a;if(n==="password"){if((0,zxcvbn_1.default)(t).score<2){const r=new error_1.LogicError(e.t("auth.weekPassword",{password:(0,password_1.randomPassword)()}));throw r.public=!0,r}return await sequelize.transaction(async r=>{const i=await User.findOne({attributes:["id"],where:{id:s},transaction:r});if(!i)throw new error_1.LogicError(e.t("auth.notFoundUser"));i.password=t,await i.save({transaction:r})}),!0}if(n==="edit")return await sequelize.transaction(async r=>{const i=await User.findOne({attributes:["id","enabled"],where:{id:s},include:[{attributes:["id","display_name"],model:UserProfile},{attributes:["id","role_id"],model:RbacUserRole,where:{app:config_1.default.appEnv},required:!1}],transaction:r});if(!i)throw new error_1.LogicError(e.t("auth.notFoundUser"));const c=[];i.enabled!==o&&(i.enabled=o,c.push(i.save({transaction:r})));const p=i.UserProfile;if(p.display_name!==d&&(p.display_name=d,c.push(p.save({transaction:r}))),i.RbacUserRoles.length&&await RbacUserRole.destroy({where:{user_id:i.id,app:config_1.default.appEnv},transaction:r}),l){if(!await RbacRole.findOne({attributes:["id"],where:{id:l,enabled:!0},transaction:r}))throw new error_1.LogicError("Role is not found.");c.push(RbacUserRole.create({user_id:i.id,app:config_1.default.appEnv,role_id:l},{transaction:r}))}await Promise.all(c)}),!0;const u=s;return await sequelize.transaction(async r=>{if(!u.length)throw new error_1.LogicError(e.t("auth.notFoundUser"));const i=await User.count({where:{id:u},transaction:r});if(u.length!==i)throw new error_1.LogicError(e.t("auth.notFoundUser"));if(l&&!await RbacRole.findOne({attributes:["id"],where:{id:l,enabled:!0},transaction:r}))throw new error_1.LogicError("Role is not found.");if(await RbacUserRole.destroy({where:{user_id:u,app:config_1.default.appEnv},transaction:r}),l){const c=lodash_1.default.map(u,p=>({user_id:p,app:config_1.default.appEnv,role_id:l}));await RbacUserRole.bulkCreate(c,{transaction:r})}}),!0};exports.editUser=editUser;const deleteUser=async(a,e)=>{const{id:s}=a,n=await User.findOne({attributes:["id"],where:{id:s}});if(!n)throw new error_1.LogicError(e.t("auth.notFoundUser"));await n.destroy()};exports.deleteUser=deleteUser;const getUserLoginHistoryList=async a=>{const{rows:e,count:s}=await UserLoginHistory.findAndCountAll({attributes:["id","node_env","app_env","email","ip","user_agent","referer","device_type","os","browser","timezone","created_at"],...a});return{total:s,list:e}};exports.getUserLoginHistoryList=getUserLoginHistoryList;const getUserAvatar=async a=>{const e=await UserProfile.findOne({attributes:["avatar","avatar_base64"],where:{user_id:a.user.id}});if(!e)throw new error_1.DataError("User is not found.");return{url:e.avatar,base64:e.avatar_base64}};exports.getUserAvatar=getUserAvatar;const saveUserProfile=async(a,e)=>{const{photo:s,displayName:n}=a,o=await UserProfile.findOne({attributes:["id","display_name","avatar","avatar_base64"],where:{user_id:e}});if(!o)throw new error_1.DataError("User profile is not found.");return s?(o.avatar=null,o.avatar_base64=s):s===null&&(o.avatar=null,o.avatar_base64=null),o.display_name=n,await o.save(),!0};exports.saveUserProfile=saveUserProfile;