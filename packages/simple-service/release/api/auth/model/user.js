"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(t,r,s,a){a===void 0&&(a=s);var e=Object.getOwnPropertyDescriptor(r,s);(!e||("get"in e?!r.__esModule:e.writable||e.configurable))&&(e={enumerable:!0,get:function(){return r[s]}}),Object.defineProperty(t,a,e)}:function(t,r,s,a){a===void 0&&(a=s),t[a]=r[s]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(t,r){Object.defineProperty(t,"default",{enumerable:!0,value:r})}:function(t,r){t.default=r}),__importStar=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var r={};if(t!=null)for(var s in t)s!=="default"&&Object.prototype.hasOwnProperty.call(t,s)&&__createBinding(r,t,s);return __setModuleDefault(r,t),r},__importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.logoutUser=exports.confirmUser=exports.unlockUser=exports.resetPassword=exports.forgotPassword=exports.register=exports.login=void 0;const helper_1=require("../helper"),zxcvbn_1=__importDefault(require("zxcvbn")),dayjs_1=__importDefault(require("dayjs")),core_1=require("@sequelize/core"),lib=__importStar(require("../../../lib")),app_1=__importDefault(require("../../../config/model/app")),password_1=require("../../../lib/util/password"),helper_2=require("../../../queue/helper"),config_1=__importDefault(require("../../../config/config")),error_1=require("../../../lib/error"),common_1=require("../../../lib/util/common"),{error:{AuthError},util,logger}=lib,{gateway:{models:{User,UserProfile,UserLoginHistory,UserToken},sequelize}}=app_1.default,login=async(t,r)=>{const{email:s,password:a}=t;let e=!1,i;const l=await sequelize.transaction(async n=>{let o=await User.findOne({where:{email:s},transaction:n});if(!o)throw logger.error(`User(${s}) is not found.`),new AuthError(r.t("auth.notFoundEmail",{email:s}));if(o.unconfirmed_email){const u=new AuthError(r.t("auth.notConfirmed"));throw u.public=!0,u}if(!o.enabled){const u=new AuthError(r.t("auth.disabledUser"));throw u.public=!0,u}if(o.reset_password_token){const u=new AuthError(r.t("auth.completePassReset"));throw u.public=!0,u}if(o=await helper_1.userHelper.checkLockStatus({user:o,User,i18n:r,transaction:n}),!o)throw logger.error(`Checked user(${s}) is not found.`),new AuthError(r.t("auth.notFoundEmail",{email:s}));const d=async()=>await helper_1.userHelper.createJwtToken({id:o.id,type:"user",transaction:n,UserToken}),c=async u=>{config_1.default.auth.traceLogin&&await UserLoginHistory.create({node_env:config_1.default.nodeEnv,app_env:config_1.default.appEnv,email:o.email,ip:t.ip,user_agent:t.userAgent,referer:t.referer,device_type:t.client?.deviceType,os:t.client?.os,browser:t.client?.browser,timezone:t.client?.timeZone,other:u||null},{transaction:n})};if(await util.password.isPasswordEqual(a,o.password))o.sign_in_count+=1,o.last_sign_in_at=o.current_sign_in_at,o.current_sign_in_at=dayjs_1.default.utc().format(),o.last_sign_in_ip=o.current_sign_in_ip,o.current_sign_in_ip=t.ip,o.failed_attempts=0,o.locked_at=null,o.unlock_token=null,await o.save({transaction:n});else{if(o.failed_attempts+=1,o.failed_attempts>=config_1.default.auth.failedAttemptCount){const u=await d();o.locked_at=dayjs_1.default.utc().format(),o.unlock_token=u,e=!0,i=o.id,c("Locked")}return await o.save({transaction:n}),null}c();let w=!1;config_1.default.auth.checkExpiredPass&&(o.last_change_pass_at?w=dayjs_1.default.utc(o.last_change_pass_at).add(config_1.default.auth.passwordResetCycle,"day").isBefore(dayjs_1.default.utc()):w=!0);const f=await d();return w?(o.reset_password_token=f,await o.save({transaction:n})):(await UserToken.destroy({where:{user_id:o.id,expired_at:{[core_1.Op.lte]:dayjs_1.default.utc().format()}},transaction:n}),o.latest_sign_in_token=f,await o.save({transaction:n})),{token:f,reset:w}});if(!l)throw e&&!config_1.default.isDev&&await helper_2.job.enqueue("auth-lock-email",{userId:i,origin:t.origin}),logger.error(`Incorrect password(${a}) of User(${s}).`),new AuthError(r.t("auth.errorPassword"));return l};exports.login=login;const register=async(t,r)=>{const{email:s,displayName:a,password:e,origin:i}=t;if((0,zxcvbn_1.default)(e).score<2){const n=new AuthError(r.t("auth.weekPassword",{password:(0,password_1.randomPassword)()}));throw n.public=!0,n}let l;return await sequelize.transaction(async n=>{if(await User.findOne({where:{email:s},transaction:n}))throw new AuthError("User has already existed.");const d=await User.create({email:s,password:e,unconfirmed_email:s,last_change_pass_at:dayjs_1.default.utc().format()},{transaction:n}),c=await helper_1.userHelper.createJwtToken({id:d.id,type:"user",transaction:n,UserToken});d.confirmation_token=c,l=d.id,await Promise.all([UserProfile.create({user_id:l,display_name:a},{transaction:n}),d.save({transaction:n})])}),config_1.default.isDev||await helper_2.job.enqueue("auth-confirmation-email",{userId:l,origin:i}),!0};exports.register=register;const forgotPassword=async({email:t,origin:r},s)=>{let a;await sequelize.transaction(async e=>{let i=await User.findOne({where:{email:t},transaction:e});if(!i)throw logger.error(`User(${t}) is not found.`),new AuthError(s.t("auth.notFoundEmail",{email:t}));if(a=i.id,i=await helper_1.userHelper.checkLockStatus({user:i,transaction:e,i18n:s,User}),!i)throw new AuthError(s.t("auth.notFoundEmail",{email:t}));const l=await helper_1.userHelper.createJwtToken({id:i.id,type:"user",transaction:e,UserToken});await i.update({reset_password_token:l},{transaction:e})}),config_1.default.isDev||await helper_2.job.enqueue("auth-forgot-email",{userId:a,origin:r})};exports.forgotPassword=forgotPassword;const resetPassword=async(t,r)=>{const s=await helper_1.userHelper.verfyJwtToken({token:t.token,UserToken});return await sequelize.transaction(async a=>{const e=await User.findOne({where:{id:s},transaction:a});if(!e)throw new error_1.DataError(r.t("auth.notFoundUser"));if(e.reset_password_token!==t.token)throw new error_1.DataError(r.t("auth.invalidToken"));if(await util.password.isPasswordEqual(t.password,e.password))throw new error_1.LogicError(r.t("auth.notSupportSamePassword"));e.reset_password_token&&await UserToken.destroy({where:{user_id:e.id,signature:(0,common_1.getJwtTokenSignature)(e.reset_password_token)},transaction:a}),e.password=t.password,e.reset_password_token=null,e.reset_password_sent_at=null,e.last_change_pass_at=dayjs_1.default.utc().format(),await e.save({transaction:a})}),!0};exports.resetPassword=resetPassword;const unlockUser=async(t,r)=>{const s=await helper_1.userHelper.verfyJwtToken({token:t.token,UserToken});return await sequelize.transaction(async a=>{const e=await User.findOne({where:{id:s},transaction:a});if(!e)throw new error_1.DataError(r.t("auth.notFoundUser"));if(e.unlock_token!==t.token)throw new error_1.DataError(r.t("auth.invalidToken"));e.unlock_token&&await UserToken.destroy({where:{user_id:e.id,signature:(0,common_1.getJwtTokenSignature)(e.unlock_token)},transaction:a}),e.unlock_token=null,e.locked_at=null,e.failed_attempts=0,await e.save({transaction:a})}),!0};exports.unlockUser=unlockUser;const confirmUser=async(t,r)=>{const s=await helper_1.userHelper.verfyJwtToken({token:t.token,UserToken});return await sequelize.transaction(async a=>{const e=await User.findOne({where:{id:s},transaction:a});if(!e)throw new error_1.DataError(r.t("auth.notFoundUser"));if(e.confirmation_token!==t.token)throw new error_1.DataError(r.t("auth.invalidToken"));e.confirmation_token&&await UserToken.destroy({where:{user_id:e.id,signature:(0,common_1.getJwtTokenSignature)(e.confirmation_token)},transaction:a}),e.confirmation_token=null,e.confirmed_at=dayjs_1.default.utc().format(),e.unconfirmed_email=null,await e.save({transaction:a})}),!0};exports.confirmUser=confirmUser;const logoutUser=async(t,r,s)=>{await sequelize.transaction(async a=>{const e=await User.findOne({attributes:["id","latest_sign_in_token"],where:{id:t},transaction:a});if(!e)throw new error_1.DataError(s.t("auth.notFoundUser"));await UserToken.destroy({where:{user_id:e.id,signature:(0,common_1.getJwtTokenSignature)(r)},transaction:a}),e.latest_sign_in_token===r&&(e.latest_sign_in_token=null),await e.save({transaction:a})})};exports.logoutUser=logoutUser;