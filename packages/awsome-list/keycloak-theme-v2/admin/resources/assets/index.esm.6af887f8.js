import{r as i}from"./index.0cb2e516.js";var wr=r=>r instanceof HTMLElement;const vr={BLUR:"blur",CHANGE:"change",INPUT:"input"},gr={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},ve="select",Pr="undefined",fr={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"};function ze({ref:r},e,t){wr(r)&&t&&(r.addEventListener(e?vr.CHANGE:vr.INPUT,t),r.addEventListener(vr.BLUR,t))}var rr=r=>r==null;const Fe=r=>typeof r=="object";var K=r=>!rr(r)&&!Array.isArray(r)&&Fe(r)&&!(r instanceof Date),Tr=r=>/^\w*$/.test(r),nr=r=>r.filter(Boolean),ke=r=>nr(r.replace(/["|']/g,"").replace(/\[/g,".").replace(/\]/g,"").split("."));function R(r,e,t){let n=-1;const l=Tr(e)?[e]:ke(e),o=l.length,a=o-1;for(;++n<o;){const A=l[n];let f=t;if(n!==a){const O=r[A];f=K(O)||Array.isArray(O)?O:isNaN(+l[n+1])?{}:[]}r[A]=f,r=r[A]}return r}var Qr=(r,e={})=>{for(const t in r)Tr(t)?e[t]=r[t]:R(e,t,r[t]);return e},W=r=>r===void 0,y=(r={},e,t)=>{const n=nr(e.split(/[,[\].]+?/)).reduce((l,o)=>rr(l)?l:l[o],r);return W(n)||n===r?W(r[e])?t:r[e]:n},Ke=(r,e)=>{for(const t in r)if(y(e,t)){const n=r[t];if(n){if(n.ref.focus&&W(n.ref.focus()))break;if(n.options){n.options[0].ref.focus();break}}}},ae=(r,e)=>{wr(r)&&r.removeEventListener&&(r.removeEventListener(vr.INPUT,e),r.removeEventListener(vr.CHANGE,e),r.removeEventListener(vr.BLUR,e))};const le={isValid:!1,value:null};var Ee=r=>Array.isArray(r)?r.reduce((e,t)=>t&&t.ref.checked?{isValid:!0,value:t.ref.value}:e,le):le,qe=r=>[...r].filter(({selected:e})=>e).map(({value:e})=>e),Nr=r=>r.type==="radio",Ce=r=>r.type==="file",Fr=r=>r.type==="checkbox",De=r=>r.type===`${ve}-multiple`;const fe={value:!1,isValid:!1},de={value:!0,isValid:!0};var Se=r=>{if(Array.isArray(r)){if(r.length>1){const l=r.filter(o=>o&&o.ref.checked).map(({ref:{value:o}})=>o);return{value:l,isValid:!!l.length}}const{checked:e,value:t,attributes:n}=r[0].ref;return e?n&&!W(n.value)?W(t)||t===""?de:{value:t,isValid:!0}:de:fe}return fe};function Rr(r,e,t,n,l){const o=r.current[e];if(o){const{ref:{value:a,disabled:A},ref:f,valueAsNumber:O,valueAsDate:M,setValueAs:v}=o;return A&&n?void 0:Ce(f)?f.files:Nr(f)?Ee(o.options).value:De(f)?qe(f.options):Fr(f)?Se(o.options).value:l?a:O?a===""?NaN:+a:M?f.valueAsDate:v?v(a):a}if(t)return y(t.current,e)}function Br(r){return r?!(r instanceof HTMLElement)||r.nodeType===Node.DOCUMENT_NODE?!1:Br(r.parentNode):!0}var B=r=>K(r)&&!Object.keys(r).length,re=r=>typeof r=="boolean";function Ue(r,e){const t=e.slice(0,-1).length;let n=0;for(;n<t;)r=W(r)?n++:r[e[n++]];return r}function G(r,e){const t=Tr(e)?[e]:ke(e),n=t.length==1?r:Ue(r,t),l=t[t.length-1];let o;n&&delete n[l];for(let a=0;a<t.slice(0,-1).length;a++){let A=-1,f;const O=t.slice(0,-(a+1)),M=O.length-1;for(a>0&&(o=r);++A<O.length;){const v=O[A];f=f?f[v]:r[v],M===A&&(K(f)&&B(f)||Array.isArray(f)&&!f.filter(N=>K(N)&&!B(N)||re(N)).length)&&(o?delete o[v]:delete r[v]),o=f}}return r}const ye=(r,e)=>r&&r.ref===e;function Je(r,e,t,n,l,o){const{ref:a,ref:{name:A}}=t,f=r.current[A];if(!l){const O=Rr(r,A,n);!W(O)&&R(n.current,A,O)}if(!a.type||!f){delete r.current[A];return}Nr(a)||Fr(a)?Array.isArray(f.options)&&f.options.length?(nr(f.options).forEach((O={},M)=>{(Br(O.ref)&&ye(O,O.ref)||o)&&(ae(O.ref,e),G(f.options,`[${M}]`))}),f.options&&!nr(f.options).length&&delete r.current[A]):delete r.current[A]:(Br(a)&&ye(f,a)||o)&&(ae(a,e),delete r.current[A])}var dr=r=>rr(r)||!Fe(r);function ee(r,e){if(dr(r)||dr(e))return e;for(const t in e){const n=r[t],l=e[t];try{r[t]=K(n)&&K(l)||Array.isArray(n)&&Array.isArray(l)?ee(n,l):l}catch{}}return r}function br(r,e,t){if(dr(r)||dr(e)||r instanceof Date||e instanceof Date)return r===e;if(!i.exports.isValidElement(r)){const n=Object.keys(r),l=Object.keys(e);if(n.length!==l.length)return!1;for(const o of n){const a=r[o];if(!(t&&o==="ref")){const A=e[o];if((K(a)||Array.isArray(a))&&(K(A)||Array.isArray(A))?!br(a,A,t):a!==A)return!1}}}return!0}function Xr(r,e,t,n,l){let o=-1;for(;++o<r.length;){for(const a in r[o])Array.isArray(r[o][a])?(!t[o]&&(t[o]={}),t[o][a]=[],Xr(r[o][a],y(e[o]||{},a,[]),t[o][a],t[o],a)):br(y(e[o]||{},a),r[o][a])?R(t[o]||{},a):t[o]=Object.assign(Object.assign({},t[o]),{[a]:!0});n&&!t.length&&delete n[l]}return t}var Yr=(r,e,t)=>ee(Xr(r,e,t.slice(0,r.length)),Xr(e,r,t.slice(0,r.length))),sr=r=>typeof r=="string",qr=(r,e,t,n,l)=>{const o={};for(const a in r.current)(W(l)||(sr(l)?a.startsWith(l):Array.isArray(l)&&l.find(A=>a.startsWith(A))))&&(o[a]=Rr(r,a,void 0,n));return t?Qr(o):ee(e,Qr(o))},Qe=({errors:r,name:e,error:t,validFields:n,fieldsWithValidation:l})=>{const o=W(t),a=y(r,e);return o&&!!a||!o&&!br(a,t,!0)||o&&y(l,e)&&!y(n,e)},je=r=>r instanceof RegExp,Cr=r=>K(r)&&!je(r)?r:{value:r,message:""},te=r=>typeof r=="function",Zr=r=>sr(r)||i.exports.isValidElement(r);function pe(r,e,t="validate"){if(Zr(r)||re(r)&&!r)return{type:t,message:Zr(r)?r:"",ref:e}}var Xe=(r,e,t,n,l)=>e?Object.assign(Object.assign({},t[r]),{types:Object.assign(Object.assign({},t[r]&&t[r].types?t[r].types:{}),{[n]:l||!0})}):{},_r=async(r,e,{ref:t,ref:{value:n},options:l,required:o,maxLength:a,minLength:A,min:f,max:O,pattern:M,validate:v},N)=>{const C=t.name,E={},$=Nr(t),F=Fr(t),er=$||F,q=n==="",P=Xe.bind(null,C,e,E),D=(I,w,V,L=fr.maxLength,m=fr.minLength)=>{const z=I?w:V;E[C]=Object.assign({type:I?L:m,message:z,ref:t},P(I?L:m,z))};if(o&&(!$&&!F&&(q||rr(n))||re(n)&&!n||F&&!Se(l).isValid||$&&!Ee(l).isValid)){const{value:I,message:w}=Zr(o)?{value:!!o,message:o}:Cr(o);if(I&&(E[C]=Object.assign({type:fr.required,message:w,ref:er?((r.current[C].options||[])[0]||{}).ref:t},P(fr.required,w)),!e))return E}if((!rr(f)||!rr(O))&&n!==""){let I,w;const V=Cr(O),L=Cr(f);if(isNaN(n)){const m=t.valueAsDate||new Date(n);sr(V.value)&&(I=m>new Date(V.value)),sr(L.value)&&(w=m<new Date(L.value))}else{const m=t.valueAsNumber||parseFloat(n);rr(V.value)||(I=m>V.value),rr(L.value)||(w=m<L.value)}if((I||w)&&(D(!!I,V.message,L.message,fr.max,fr.min),!e))return E}if(sr(n)&&!q&&(a||A)){const I=Cr(a),w=Cr(A),V=!rr(I.value)&&n.length>I.value,L=!rr(w.value)&&n.length<w.value;if((V||L)&&(D(V,I.message,w.message),!e))return E}if(sr(n)&&M&&!q){const{value:I,message:w}=Cr(M);if(je(I)&&!I.test(n)&&(E[C]=Object.assign({type:fr.pattern,message:w,ref:t},P(fr.pattern,w)),!e))return E}if(v){const I=Rr(r,C,N,!1,!0),w=er&&l?l[0].ref:t;if(te(v)){const V=await v(I),L=pe(V,w);if(L&&(E[C]=Object.assign(Object.assign({},L),P(fr.validate,L.message)),!e))return E}else if(K(v)){let V={};for(const[L,m]of Object.entries(v)){if(!B(V)&&!e)break;const z=await m(I),Q=pe(z,w,L);Q&&(V=Object.assign(Object.assign({},Q),P(L,Q.message)),e&&(E[C]=V))}if(!B(V)&&(E[C]=Object.assign({ref:w},V),!e))return E}}return E};const se=(r,e,t=[])=>{for(const n in e){const l=r+(K(e)?`.${n}`:`[${n}]`);dr(e[n])?t.push(l):se(l,e[n],t)}return t};var ge=(r,e,t,n,l)=>{let o;return t.add(e),B(r)||(o=y(r,e),(K(o)||Array.isArray(o))&&se(e,o).forEach(a=>t.add(a))),W(o)?l?n:y(n,e):o},we=({isOnBlur:r,isOnChange:e,isOnTouch:t,isTouched:n,isReValidateOnBlur:l,isReValidateOnChange:o,isBlurEvent:a,isSubmitted:A,isOnAll:f})=>f?!1:!A&&t?!(n||a):(A?l:r)?!a:(A?o:e)?a:!0,Sr=r=>r.substring(0,r.indexOf("["));const Ie=(r,e)=>RegExp(`^${e}([|.)\\d+`.replace(/\[/g,"\\[").replace(/\]/g,"\\]")).test(r);var Le=(r,e)=>[...r].some(t=>Ie(e,t)),Ye=r=>r.type===`${ve}-one`;function Ze(r,e){const t=new MutationObserver(()=>{for(const n of Object.values(r.current))if(n&&n.options)for(const l of n.options)l&&l.ref&&Br(l.ref)&&e(n);else n&&Br(n.ref)&&e(n)});return t.observe(window.document,{childList:!0,subtree:!0}),t}var jr=typeof window!==Pr&&typeof document!==Pr;function ir(r){var e;let t;if(dr(r)||jr&&(r instanceof File||wr(r))||!["Set","Map","Object","Date","Array"].includes((e=r.constructor)===null||e===void 0?void 0:e.name))return r;if(r instanceof Date)return t=new Date(r.getTime()),t;if(r instanceof Set){t=new Set;for(const n of r)t.add(n);return t}if(r instanceof Map){t=new Map;for(const n of r.keys())t.set(n,ir(r.get(n)));return t}t=Array.isArray(r)?[]:{};for(const n in r)t[n]=ir(r[n]);return t}var be=r=>({isOnSubmit:!r||r===gr.onSubmit,isOnBlur:r===gr.onBlur,isOnChange:r===gr.onChange,isOnAll:r===gr.all,isOnTouch:r===gr.onTouched}),xe=r=>Nr(r)||Fr(r);const rt=typeof window===Pr,Or=jr?"Proxy"in window:typeof Proxy!==Pr;function ct({mode:r=gr.onSubmit,reValidateMode:e=gr.onChange,resolver:t,context:n,defaultValues:l={},shouldFocusError:o=!0,shouldUnregister:a=!0,criteriaMode:A}={}){const f=i.exports.useRef({}),O=i.exports.useRef({}),M=i.exports.useRef({}),v=i.exports.useRef(new Set),N=i.exports.useRef({}),C=i.exports.useRef({}),E=i.exports.useRef({}),$=i.exports.useRef({}),F=i.exports.useRef(l),er=i.exports.useRef(!1),q=i.exports.useRef(!1),P=i.exports.useRef(),D=i.exports.useRef({}),I=i.exports.useRef({}),w=i.exports.useRef(n),V=i.exports.useRef(t),L=i.exports.useRef(new Set),m=i.exports.useRef(be(r)),{isOnSubmit:z,isOnTouch:Q}=m.current,H=A===gr.all,[Y,or]=i.exports.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touched:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!z,errors:{}}),T=i.exports.useRef({isDirty:!Or,dirtyFields:!Or,touched:!Or||Q,isValidating:!Or,isSubmitting:!Or,isValid:!Or}),d=i.exports.useRef(Y),U=i.exports.useRef(),{isOnBlur:ar,isOnChange:X}=i.exports.useRef(be(e)).current;w.current=n,V.current=t,d.current=Y,D.current=a?{}:B(D.current)?ir(l):D.current;const S=i.exports.useCallback((s={})=>{er.current||(d.current=Object.assign(Object.assign({},d.current),s),or(d.current))},[]),mr=()=>T.current.isValidating&&S({isValidating:!0}),xr=i.exports.useCallback((s,u,c=!1,x={},h)=>{let g=c||Qe({errors:d.current.errors,error:u,name:s,validFields:$.current,fieldsWithValidation:E.current});const k=y(d.current.errors,s);u?(G($.current,s),g=g||!k||!br(k,u,!0),R(d.current.errors,s,u)):((y(E.current,s)||V.current)&&(R($.current,s,!0),g=g||k),G(d.current.errors,s)),(g&&!rr(c)||!B(x)||T.current.isValidating)&&S(Object.assign(Object.assign(Object.assign({},x),V.current?{isValid:!!h}:{}),{isValidating:!1}))},[]),yr=i.exports.useCallback((s,u)=>{const{ref:c,options:x}=f.current[s],h=jr&&wr(c)&&rr(u)?"":u;Nr(c)?(x||[]).forEach(({ref:g})=>g.checked=g.value===h):Ce(c)&&!sr(h)?c.files=h:De(c)?[...c.options].forEach(g=>g.selected=h.includes(g.value)):Fr(c)&&x?x.length>1?x.forEach(({ref:g})=>g.checked=Array.isArray(h)?!!h.find(k=>k===g.value):h===g.value):x[0].ref.checked=!!h:c.value=h},[]),Ir=i.exports.useCallback((s,u)=>{if(T.current.isDirty){const c=kr();return s&&u&&R(c,s,u),!br(c,F.current)}return!1},[]),hr=i.exports.useCallback((s,u=!0)=>{if(T.current.isDirty||T.current.dirtyFields){const c=!br(y(F.current,s),Rr(f,s,D)),x=y(d.current.dirtyFields,s),h=d.current.isDirty;c?R(d.current.dirtyFields,s,!0):G(d.current.dirtyFields,s);const g={isDirty:Ir(),dirtyFields:d.current.dirtyFields},k=T.current.isDirty&&h!==g.isDirty||T.current.dirtyFields&&x!==y(d.current.dirtyFields,s);return k&&u&&S(g),k?g:{}}return{}},[]),Lr=i.exports.useCallback(async(s,u)=>{const c=(await _r(f,H,f.current[s],D))[s];return xr(s,c,u),W(c)},[xr,H]),p=i.exports.useCallback(async s=>{const{errors:u}=await V.current(kr(),w.current,H),c=d.current.isValid;if(Array.isArray(s)){const x=s.map(h=>{const g=y(u,h);return g?R(d.current.errors,h,g):G(d.current.errors,h),!g}).every(Boolean);return S({isValid:B(u),isValidating:!1}),x}else{const x=y(u,s);return xr(s,x,c!==B(u),{},B(u)),!x}},[xr,H]),b=i.exports.useCallback(async s=>{const u=s||Object.keys(f.current);if(mr(),V.current)return p(u);if(Array.isArray(u)){!s&&(d.current.errors={});const c=await Promise.all(u.map(async x=>await Lr(x,null)));return S({isValidating:!1}),c.every(Boolean)}return await Lr(u)},[p,Lr]),j=i.exports.useCallback((s,u,{shouldDirty:c,shouldValidate:x})=>{const h={};R(h,s,u);for(const g of se(s,u))f.current[g]&&(yr(g,y(h,g)),c&&hr(g),x&&b(g))},[b,yr,hr]),J=i.exports.useCallback((s,u,c)=>{if(!a&&!dr(u)&&R(D.current,s,Array.isArray(u)?[...u]:Object.assign({},u)),f.current[s])yr(s,u),c.shouldDirty&&hr(s),c.shouldValidate&&b(s);else if(!dr(u)&&(j(s,u,c),L.current.has(s))){const x=Sr(s)||s;R(O.current,s,u),I.current[x]({[x]:y(O.current,x)}),(T.current.isDirty||T.current.dirtyFields)&&c.shouldDirty&&(R(d.current.dirtyFields,s,Yr(u,y(F.current,s,[]),y(d.current.dirtyFields,s,[]))),S({isDirty:!br(Object.assign(Object.assign({},kr()),{[s]:u}),F.current)}))}!a&&R(D.current,s,u)},[hr,yr,j]),cr=s=>q.current||v.current.has(s)||v.current.has((s.match(/\w+/)||[])[0]),ur=s=>{let u=!0;if(!B(N.current))for(const c in N.current)(!s||!N.current[c].size||N.current[c].has(s)||N.current[c].has(Sr(s)))&&(C.current[c](),u=!1);return u};function lr(s,u,c){J(s,u,c||{}),cr(s)&&S(),ur(s)}P.current=P.current?P.current:async({type:s,target:u})=>{let c=u.name;const x=f.current[c];let h,g;if(x){const k=s===vr.BLUR,Z=we(Object.assign({isBlurEvent:k,isReValidateOnChange:X,isReValidateOnBlur:ar,isTouched:!!y(d.current.touched,c),isSubmitted:d.current.isSubmitted},m.current));let tr=hr(c,!1),Er=!B(tr)||!k&&cr(c);if(k&&!y(d.current.touched,c)&&T.current.touched&&(R(d.current.touched,c,!0),tr=Object.assign(Object.assign({},tr),{touched:d.current.touched})),!a&&Fr(u)&&R(D.current,c,Rr(f,c)),Z)return!k&&ur(c),(!B(tr)||Er&&B(tr))&&S(tr);if(mr(),V.current){const{errors:_}=await V.current(kr(),w.current,H),Mr=d.current.isValid;if(h=y(_,c),Fr(u)&&!h&&V.current){const pr=Sr(c),Ar=y(_,pr,{});Ar.type&&Ar.message&&(h=Ar),pr&&(Ar||y(d.current.errors,pr))&&(c=pr)}g=B(_),Mr!==g&&(Er=!0)}else h=(await _r(f,H,x,D))[c];!k&&ur(c),xr(c,h,Er,tr,g)}};function ie(s){if(!a){let u=ir(s);for(const c of L.current)Tr(c)&&!u[c]&&(u=Object.assign(Object.assign({},u),{[c]:[]}));return u}return s}function kr(s){if(sr(s))return Rr(f,s,D);if(Array.isArray(s)){const u={};for(const c of s)R(u,c,Rr(f,c,D));return u}return ie(qr(f,ir(D.current),a))}const Wr=i.exports.useCallback(async(s={})=>{const u=B(f.current)?F.current:{},{errors:c}=await V.current(Object.assign(Object.assign(Object.assign({},u),kr()),s),w.current,H)||{},x=B(c);d.current.isValid!==x&&S({isValid:x})},[H]),$r=i.exports.useCallback((s,u)=>{Je(f,P.current,s,D,a,u),a&&(G($.current,s.ref.name),G(E.current,s.ref.name))},[a]),Gr=i.exports.useCallback(s=>{if(q.current)S();else{for(const u of v.current)if(u.startsWith(s)){S();break}ur(s)}},[]),Hr=i.exports.useCallback((s,u)=>{s&&($r(s,u),a&&!nr(s.options||[]).length&&(G(d.current.errors,s.ref.name),R(d.current.dirtyFields,s.ref.name,!0),S({isDirty:Ir()}),T.current.isValid&&V.current&&Wr(),Gr(s.ref.name)))},[Wr,$r]);function Pe(s){s&&(Array.isArray(s)?s:[s]).forEach(u=>f.current[u]&&Tr(u)?delete d.current.errors[u]:G(d.current.errors,u)),S({errors:s?d.current.errors:{}})}function Te(s,u){const c=(f.current[s]||{}).ref;R(d.current.errors,s,Object.assign(Object.assign({},u),{ref:c})),S({isValid:!1}),u.shouldFocus&&c&&c.focus&&c.focus()}const zr=i.exports.useCallback((s,u,c)=>{const x=c?N.current[c]:v.current;let h=qr(f,ir(D.current),a,!1,s);if(sr(s)){const k=Sr(s)||s;return L.current.has(k)&&(h=Object.assign(Object.assign({},M.current),h)),ge(h,s,x,W(y(F.current,s))?u:y(F.current,s),!0)}const g=W(u)?F.current:u;return Array.isArray(s)?s.reduce((k,Z)=>Object.assign(Object.assign({},k),{[Z]:ge(h,Z,x,g)}),{}):(q.current=W(c),Qr(!B(h)&&h||g))},[]);function Be(s,u){return zr(s,u)}function Ne(s){for(const u of Array.isArray(s)?s:[s])Hr(f.current[u],!0)}function Kr(s,u={}){const{name:c,type:x,value:h}=s,g=Object.assign({ref:s},u),k=f.current,Z=xe(s),tr=Le(L.current,c),Er=Vr=>jr&&(!wr(s)||Vr===s);let _=k[c],Mr=!0,pr;if(_&&(Z?Array.isArray(_.options)&&nr(_.options).find(Vr=>h===Vr.ref.value&&Er(Vr.ref)):Er(_.ref))){k[c]=Object.assign(Object.assign({},_),u);return}x?_=Z?Object.assign({options:[...nr(_&&_.options||[]),{ref:s}],ref:{type:x,name:c}},u):Object.assign({},g):_=g,k[c]=_;const Ar=W(y(D.current,c));(!B(F.current)||!Ar)&&(pr=y(Ar?F.current:D.current,c),Mr=W(pr),!Mr&&!tr&&yr(c,pr)),B(u)||(R(E.current,c,!0),!z&&T.current.isValid&&_r(f,H,_,D).then(Vr=>{const Ge=d.current.isValid;B(Vr)?R($.current,c,!0):G($.current,c),Ge!==B(Vr)&&S()})),a&&!(tr&&Mr)&&!tr&&G(d.current.dirtyFields,c),x&&ze(Z&&_.options?_.options[_.options.length-1]:_,Z||Ye(s),P.current)}function me(s,u){if(!rt)if(sr(s))Kr({name:s},u);else if(K(s)&&"name"in s)Kr(s,u);else return c=>c&&Kr(c,s)}const We=i.exports.useCallback((s,u)=>async c=>{c&&c.preventDefault&&(c.preventDefault(),c.persist());let x={},h=ie(qr(f,ir(D.current),a,!0));T.current.isSubmitting&&S({isSubmitting:!0});try{if(V.current){const{errors:g,values:k}=await V.current(h,w.current,H);d.current.errors=x=g,h=k}else for(const g of Object.values(f.current))if(g){const{name:k}=g.ref,Z=await _r(f,H,g,D);Z[k]?(R(x,k,Z[k]),G($.current,k)):y(E.current,k)&&(G(d.current.errors,k),R($.current,k,!0))}B(x)&&Object.keys(d.current.errors).every(g=>g in f.current)?(S({errors:{},isSubmitting:!0}),await s(h,c)):(d.current.errors=Object.assign(Object.assign({},d.current.errors),x),u&&await u(d.current.errors,c),o&&Ke(f.current,d.current.errors))}finally{d.current.isSubmitting=!1,S({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:B(d.current.errors),submitCount:d.current.submitCount+1})}},[o,H]),$e=({errors:s,isDirty:u,isSubmitted:c,touched:x,isValid:h,submitCount:g,dirtyFields:k})=>{h||($.current={},E.current={}),O.current={},v.current=new Set,q.current=!1,S({submitCount:g?d.current.submitCount:0,isDirty:u?d.current.isDirty:!1,isSubmitted:c?d.current.isSubmitted:!1,isValid:h?d.current.isValid:!1,dirtyFields:k?d.current.dirtyFields:{},touched:x?d.current.touched:{},errors:s?d.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})},He=(s,u={})=>{if(jr){for(const c of Object.values(f.current))if(c){const{ref:x,options:h}=c,g=xe(x)&&Array.isArray(h)?h[0].ref:x;if(wr(g))try{g.closest("form").reset();break}catch{}}}f.current={},F.current=Object.assign({},s||F.current),s&&ur(""),Object.values(I.current).forEach(c=>te(c)&&c()),D.current=a?{}:ir(s||F.current),$e(u)};i.exports.useEffect(()=>{t&&T.current.isValid&&Wr(),U.current=U.current||!jr?U.current:Ze(f,Hr)},[Hr,F.current]),i.exports.useEffect(()=>()=>{U.current&&U.current.disconnect(),er.current=!0,Object.values(f.current).forEach(s=>Hr(s,!0))},[]),!t&&T.current.isValid&&(Y.isValid=br($.current,E.current)&&B(d.current.errors));const oe={trigger:b,setValue:i.exports.useCallback(lr,[J,b]),getValues:i.exports.useCallback(kr,[]),register:i.exports.useCallback(me,[F.current]),unregister:i.exports.useCallback(Ne,[]),formState:Or?new Proxy(Y,{get:(s,u)=>{if(u in s)return T.current[u]=!0,s[u]}}):Y},_e=i.exports.useMemo(()=>Object.assign({isFormDirty:Ir,updateWatchedValue:Gr,shouldUnregister:a,updateFormState:S,removeFieldEventListener:$r,watchInternal:zr,mode:m.current,reValidateMode:{isReValidateOnBlur:ar,isReValidateOnChange:X},validateResolver:t?Wr:void 0,fieldsRef:f,resetFieldArrayFunctionRef:I,useWatchFieldsRef:N,useWatchRenderFunctionsRef:C,fieldArrayDefaultValuesRef:O,validFieldsRef:$,fieldsWithValidationRef:E,fieldArrayNamesRef:L,readFormStateRef:T,formStateRef:d,defaultValuesRef:F,shallowFieldsStateRef:D,fieldArrayValuesRef:M},oe),[F.current,Gr,a,$r,zr]);return Object.assign({watch:Be,control:_e,handleSubmit:We,reset:i.exports.useCallback(He,[]),clearErrors:i.exports.useCallback(Pe,[]),setError:i.exports.useCallback(Te,[]),errors:Y.errors},oe)}/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function ne(r,e){var t={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&e.indexOf(n)<0&&(t[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var l=0,n=Object.getOwnPropertySymbols(r);l<n.length;l++)e.indexOf(n[l])<0&&Object.prototype.propertyIsEnumerable.call(r,n[l])&&(t[n[l]]=r[n[l]]);return t}const ce=i.exports.createContext(null);ce.displayName="RHFContext";const ue=()=>i.exports.useContext(ce),ut=r=>{var{children:e}=r,t=ne(r,["children"]);return i.exports.createElement(ce.Provider,{value:Object.assign({},t)},e)};var Me=()=>{const r=typeof performance===Pr?Date.now():performance.now()*1e3;return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=(Math.random()*16+r)%16|0;return(e=="x"?t:t&3|8).toString(16)})};function et(r,e){let t=0;const n=[...r];for(const l of e)n.splice(l-t,1),t++;return nr(n).length?n:[]}var Ur=(r,e)=>W(e)?[]:et(r,(Array.isArray(e)?e:[e]).sort((t,n)=>t-n)),he=(r,e,t)=>Array.isArray(r)?(W(r[t])&&(r[t]=void 0),r.splice(t,0,r.splice(e,1)[0]),r):[],Ae=(r,e,t)=>{const n=[r[t],r[e]];r[e]=n[0],r[t]=n[1]};function Ve(r,e){return[...Array.isArray(e)?e:[e||void 0],...r]}function Jr(r,e,t){return[...r.slice(0,e),...Array.isArray(t)?t:[t||void 0],...r.slice(e)]}var Oe=r=>Array.isArray(r)?Array(r.length).fill(void 0):void 0,Re=r=>(Array.isArray(r)?r:[r]).map(e=>{if(K(e)){const t={};for(const n in e)t[n]=!0;return t}return!0});const Dr=(r=[],e,t)=>r.map(n=>Object.assign({[e]:n[e]||Me()},n)),it=({control:r,name:e,keyName:t="id"})=>{const n=ue(),l=i.exports.useRef(-1),o=i.exports.useRef(!1),{isFormDirty:a,updateWatchedValue:A,resetFieldArrayFunctionRef:f,fieldArrayNamesRef:O,fieldsRef:M,defaultValuesRef:v,removeFieldEventListener:N,formStateRef:C,shallowFieldsStateRef:E,updateFormState:$,readFormStateRef:F,validFieldsRef:er,fieldsWithValidationRef:q,fieldArrayDefaultValuesRef:P,validateResolver:D,getValues:I,shouldUnregister:w,fieldArrayValuesRef:V}=r||n.control,L=p=>y(w?p:E.current,e,[]),m=Sr(e),z=i.exports.useRef([...y(P.current,m)?L(P.current):L(v.current)]),[Q,H]=i.exports.useState(Dr(z.current,t));R(V.current,e,nr(Q));const Y=p=>p.map((b={})=>{var j=t;b[j];var J=ne(b,[typeof j=="symbol"?j:j+""]);return J});O.current.add(e);const or=i.exports.useCallback(()=>y(V.current,e,[]),[e]),T=()=>Dr(y(I(),e,or()).map((p,b)=>Object.assign(Object.assign({},or()[b]),p)),t);O.current.add(e),m&&!y(P.current,m)&&R(P.current,m,ir(y(v.current,m)));const d=p=>{if(H(p),R(V.current,e,p),F.current.isValid&&D){const b=I();R(b,e,p),D(b)}},U=()=>{for(const p in M.current)Ie(p,e)&&(N(M.current[p],!0),delete M.current[p])},ar=p=>!nr(y(p,e,[])).length&&G(p,e),X=p=>{p&&R(C.current.dirtyFields,e,Yr(Y(p),y(v.current,e,[]),y(C.current.dirtyFields,e,[])))},S=(p,b,j,J=[],cr=!0,ur=!1)=>{if(y(E.current,e)){const lr=p(y(E.current,e),b.argA,b.argB);cr&&R(E.current,e,lr)}if(y(P.current,e)){const lr=p(y(P.current,e),b.argA,b.argB);cr&&R(P.current,e,lr)}if(Array.isArray(y(C.current.errors,e))){const lr=p(y(C.current.errors,e),b.argA,b.argB);cr&&R(C.current.errors,e,lr),ar(C.current.errors)}if(F.current.touched&&y(C.current.touched,e)){const lr=p(y(C.current.touched,e),b.argA,b.argB);cr&&R(C.current.touched,e,lr),ar(C.current.touched)}(F.current.dirtyFields||F.current.isDirty)&&(R(C.current.dirtyFields,e,Yr(Y(J),y(v.current,e,[]),y(C.current.dirtyFields,e,[]))),X(j),ar(C.current.dirtyFields)),ur&&F.current.isValid&&!D&&(R(er.current,e,p(y(er.current,e,[]),b.argA)),ar(er.current),R(q.current,e,p(y(q.current,e,[]),b.argA)),ar(q.current)),!o.current&&F.current.isDirty&&$({isDirty:a(e,Y(J))})},mr=(p,b=!0)=>{const j=Array.isArray(p)?p:[p],J=[...T(),...Dr(j,t)];d(J),(F.current.dirtyFields||F.current.isDirty)&&(X(J),$({isDirty:!0,dirtyFields:C.current.dirtyFields})),!w&&R(E.current,e,[...y(E.current,e)||[],...ir(j)]),l.current=b?y(V.current,e).length-1:-1},xr=(p,b=!0)=>{const j=Oe(p),J=Ve(T(),Dr(Array.isArray(p)?p:[p],t));d(J),U(),S(Ve,{argA:j,argC:Re(p)},J),l.current=b?0:-1},yr=p=>{const b=T(),j=Ur(b,p);d(j),U(),S(Ur,{argA:p,argC:p},j,Ur(b,p),!0,!0)},Ir=(p,b,j=!0)=>{const J=Oe(b),cr=T(),ur=Jr(cr,p,Dr(Array.isArray(b)?b:[b],t));d(ur),U(),S(Jr,{argA:p,argB:J,argC:p,argD:Re(b)},ur,Jr(cr,p)),l.current=j?p:-1},hr=(p,b)=>{const j=T();Ae(j,p,b),U(),d([...j]),S(Ae,{argA:p,argB:b,argC:p,argD:b},void 0,j,!1)},Lr=(p,b)=>{const j=T();he(j,p,b),U(),d([...j]),S(he,{argA:p,argB:b,argC:p,argD:b},void 0,j,!1)};return i.exports.useEffect(()=>{const p=y(P.current,e);if(p&&Q.length<p.length&&R(P.current,e,p.slice(1)),A(e),l.current>-1)for(const b in M.current){const j=M.current[b];if(b.startsWith(`${e}[${l.current}]`)&&j.ref.focus){j.ref.focus();break}}l.current=-1},[Q,e]),i.exports.useEffect(()=>{const p=f.current,b=O.current;return Sr(e)||(p[e]=j=>{U(),!j&&G(P.current,e),G(E.current,e),z.current=y(j||v.current,e),o.current||H(Dr(z.current,t))}),()=>{o.current=!0,w&&yr(),U(),delete p[e],G(V.current,e),b.delete(e)}},[]),{swap:i.exports.useCallback(hr,[e]),move:i.exports.useCallback(Lr,[e]),prepend:i.exports.useCallback(xr,[e]),append:i.exports.useCallback(mr,[e]),remove:i.exports.useCallback(yr,[e]),insert:i.exports.useCallback(Ir,[e]),fields:nr(Q)}};var tt=r=>dr(r)||!K(r.target)||K(r.target)&&!r.type?r:W(r.target.value)?r.target.checked:r.target.value;function st({name:r,rules:e,defaultValue:t,control:n,onFocus:l}){const o=ue(),{defaultValuesRef:a,setValue:A,register:f,unregister:O,trigger:M,mode:v,reValidateMode:{isReValidateOnBlur:N,isReValidateOnChange:C},formState:E,formStateRef:{current:{isSubmitted:$,touched:F,errors:er}},updateFormState:q,readFormStateRef:P,fieldsRef:D,fieldArrayNamesRef:I,shallowFieldsStateRef:w}=n||o.control,V=!Le(I.current,r),L=()=>!W(y(w.current,r))&&V?y(w.current,r):W(t)?y(a.current,r):t,[m,z]=i.exports.useState(L()),Q=i.exports.useRef(m),H=i.exports.useRef({focus:()=>null}),Y=i.exports.useRef(l||(()=>{te(H.current.focus)&&H.current.focus()})),or=i.exports.useCallback(X=>!we(Object.assign({isBlurEvent:X,isReValidateOnBlur:N,isReValidateOnChange:C,isSubmitted:$,isTouched:!!y(F,r)},v)),[N,C,$,F,r,v]),T=i.exports.useCallback(([X])=>{const S=tt(X);return z(S),Q.current=S,S},[]),d=i.exports.useCallback(X=>{D.current[r]?D.current[r]=Object.assign({ref:D.current[r].ref},e):(f(Object.defineProperties({name:r,focus:Y.current},{value:{set(S){z(S),Q.current=S},get(){return Q.current}}}),e),X=W(y(a.current,r))),X&&V&&z(L())},[e,r,f]);i.exports.useEffect(()=>()=>O(r),[r]),i.exports.useEffect(()=>{d()},[d]),i.exports.useEffect(()=>{!D.current[r]&&d(!0)});const U=i.exports.useCallback(()=>{P.current.touched&&!y(F,r)&&(R(F,r,!0),q({touched:F})),or(!0)&&M(r)},[r,q,or,M,P]);return{field:{onChange:i.exports.useCallback((...X)=>A(r,T(X),{shouldValidate:or(),shouldDirty:!0}),[A,r,or]),onBlur:U,name:r,value:m,ref:H},meta:Object.defineProperties({invalid:!!y(er,r)},{isDirty:{get(){return!!y(E.dirtyFields,r)}},isTouched:{get(){return!!y(E.touched,r)}}})}}function ot({control:r,name:e,defaultValue:t}){const n=ue(),{useWatchFieldsRef:l,useWatchRenderFunctionsRef:o,watchInternal:a,defaultValuesRef:A}=r||n.control,f=i.exports.useState()[1],O=i.exports.useRef(),M=i.exports.useRef(t);return i.exports.useEffect(()=>{const v=O.current=Me(),N=o.current,C=l.current;return C[v]=new Set,N[v]=()=>f({}),a(e,M.current,v),()=>{delete C[v],delete N[v]}},[e,o,l,a,M]),O.current?a(e,M.current,O.current):W(t)?sr(e)?y(A.current,e):Array.isArray(e)?e.reduce((v,N)=>Object.assign(Object.assign({},v),{[N]:y(A.current,N)}),{}):A.current:t}const at=r=>{const{rules:e,as:t,render:n,defaultValue:l,control:o,onFocus:a}=r,A=ne(r,["rules","as","render","defaultValue","control","onFocus"]),{field:f,meta:O}=st(r),M=Object.assign(Object.assign({},A),f);return t?i.exports.isValidElement(t)?i.exports.cloneElement(t,M):i.exports.createElement(t,M):n?n(f,O):null};export{at as C,ut as F,ue as a,ot as b,it as c,ct as u};
